<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>RaceMann Pilot — RN табло</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      background:#07080c; color:#eef0f4;
    }

    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; padding-bottom: 24px; }
    .card {
      border:1px solid #262b35;
      border-radius: 18px;
      padding: 12px;
      background:#10131a;
      margin-top: 12px;
    }
    h1 { font-size: 16px; margin: 0; font-weight: 900; letter-spacing: -0.02em; }
    .muted { color:#9aa3ad; font-size: 13px; line-height: 1.35; }

    label { display:block; font-weight: 900; margin-bottom: 6px; font-size: 12px; color:#cdd3dc; }
    input, button, textarea {
      font-size: 16px; padding: 12px 12px;
      border-radius: 14px; border: 1px solid #262b35;
      background:#0b0e14; color:#eef0f4;
      width: 100%;
    }
    input::placeholder { color:#6f7782; }
    button {
      cursor:pointer; font-weight: 900;
      background:#1f6feb; border-color:#1f6feb;
    }
    button.secondary { background:#0b0e14; border-color:#262b35; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: end; }
    .row > * { flex: 1 1 260px; }
    .smallnote { margin-top: 8px; color:#9aa3ad; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid #262b35;
      color:#9aa3ad;
      font-size: 12px;
      background:#0b0e14;
    }
    .dot { width: 10px; height: 10px; border-radius: 999px; background:#666; display:inline-block; }
    .dot.ok { background:#26a269; }
    .dot.bad { background:#d13212; }

    .logBox {
      margin-top: 12px;
      border:1px solid #262b35;
      border-radius: 14px;
      background:#0b0e14;
      padding: 10px;
    }
    .logBoxHeader {
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom: 8px;
    }
    .logBoxHeader b { font-size: 12px; color:#cdd3dc; }
    .log {
      width: 100%;
      height: 180px;
      resize: vertical;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre;
      overflow: auto;
    }

    /* ===== Pilot screen ===== */
    .pilot {
      min-height: 100svh;
      padding: 14px;
      padding-bottom: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .pilotTopBar {
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .pilotTitle {
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
    }
    .pilotTitle b { font-size: 13px; color:#cdd3dc; }
    .pilotMeta { color:#9aa3ad; font-size: 12px; }

    .board { flex: 1; display:flex; flex-direction: column; gap: 12px; }

    .tile {
      border:1px solid #262b35;
      border-radius: 22px;
      background:#0b0e14;
      padding: 14px;
    }
    .tile .t { color:#9aa3ad; font-size: 12px; font-weight: 900; letter-spacing:.02em; }
    .tile .v {
      font-weight: 1000;
      letter-spacing: -0.03em;
      margin-top: 6px;
      line-height: 1;
      transform-origin: 50% 65%;
      will-change: transform, filter, opacity;
    }

    .bigRow {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .tile.big .v { font-size: 72px; }

    .smallRow {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .tile.small .v { font-size: 46px; }

    .green  { color: #26a269; }
    .purple { color: #bb6bff; }

    @keyframes pop {
      0%   { transform: scale(1);    filter: brightness(1);    opacity: 1; }
      30%  { transform: scale(1.06); filter: brightness(1.25); opacity: 1; }
      100% { transform: scale(1);    filter: brightness(1);    opacity: 1; }
    }
    .pop { animation: pop 240ms ease-out; }

    .btnRow { display:flex; gap:10px; flex-wrap: wrap; }
    .btnRow button { width:auto; padding: 10px 12px; }

    .hidden { display:none !important; }
  </style>
</head>
<body>

  <!-- ===== SETUP ===== -->
  <div id="setupScreen" class="wrap">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <h1>RaceMann Pilot — RN табло</h1>
        <span class="pill"><span id="dotSetup" class="dot bad"></span><b id="statusSetup">idle</b></span>
      </div>

      <div class="muted" style="margin-top:8px">
        Мы берём актуальный <b>raceId</b> автоматически из SignalR страницы
        <span class="mono">https://miks.racemann.com/home/last#race</span>.
        Введи только <b>RN</b>.
      </div>

      <div class="row" style="margin-top:12px">
        <div style="flex: 1 1 220px;">
          <label>RN</label>
          <input id="rn" inputmode="numeric" placeholder="например 1" />
          <div class="smallnote">Номер карта / RN.</div>
        </div>

        <div style="flex: 2 1 520px;">
          <label>Актуальный raceId</label>
          <input id="raceIdBox" class="mono" readonly value="—" />
          <div class="smallnote">Источник: <span class="mono">/home/last</span></div>
        </div>

        <div style="flex: 1 1 260px;">
          <label>&nbsp;</label>
          <button id="btnOpen" disabled>Открыть экран пилота</button>
          <div class="smallnote" id="raceLinkLine" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="logBox">
        <div class="logBoxHeader">
          <b>Debug: lastRaceId watcher</b>
          <button id="btnClearLog" class="secondary">Очистить</button>
        </div>
        <textarea id="log" class="log mono" readonly></textarea>
        <div class="smallnote" style="margin-top:8px">
          Если raceId не подтягивается — пришли сюда 10–20 строк из лога.
        </div>
      </div>

      <div class="smallnote" style="margin-top:12px">
        Worker: <span class="mono">racemann-api.vsmirnoff.workers.dev</span>
      </div>
    </div>
  </div>

  <!-- ===== PILOT SCREEN ===== -->
  <div id="pilotScreen" class="pilot hidden">
    <div class="pilotTopBar">
      <div class="pilotTitle">
        <span class="pill"><span id="dotPilot" class="dot bad"></span><b id="statusPilot">disconnected</b></span>
        <div>
          <div><b>RN:</b> <span id="rnShow">—</span></div>
          <div class="pilotMeta" id="metaLine">—</div>
        </div>
      </div>

      <div class="btnRow">
        <button id="btnBack" class="secondary">Назад</button>
        <button id="btnDisconnect" class="secondary" disabled>Disconnect</button>
      </div>
    </div>

    <div class="board">
      <div class="bigRow">
        <div class="tile big">
          <div class="t">Позиция</div>
          <div id="kPos" class="v">—</div>
        </div>

        <div class="tile big">
          <div class="t">Последний круг</div>
          <div id="kLast" class="v">—</div>
        </div>
      </div>

      <div class="smallRow">
        <div class="tile small">
          <div class="t">Лучший круг пилота</div>
          <div id="kBestPilot" class="v green">—</div>
        </div>

        <div class="tile small">
          <div class="t">Лучший круг заезда</div>
          <div id="kBestRace" class="v purple">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const WORKER_HOST = "racemann-api.vsmirnoff.workers.dev";
  const HOME_LAST_URL = "https://miks.racemann.com/home/last#race";
  const LS_RN = "rm_pilot_rn";
  const $ = (id) => document.getElementById(id);

  let wsPilot = null;
  let wsLast = null;

  const state = {
    raceId: null,
    raceIdUpdatedAt: null,
    raceIdWsConnected: false,

    byRn: new Map(),
    bestRaceMs: null,

    lastFrameAt: null,
    frames: 0,
    compCount: 0,

    pilotConnected: false,
  };

  // ===== logging =====
  const logLines = [];
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    logLines.push(`[${ts}] ${line}`);
    while (logLines.length > 200) logLines.shift();
    $("log").value = logLines.slice(-40).join("\n");
    $("log").scrollTop = $("log").scrollHeight;
  }

  // ===== UI helpers =====
  function setDot(where, ok) {
    const dot = where === "setup" ? $("dotSetup") : $("dotPilot");
    dot.classList.toggle("ok", !!ok);
    dot.classList.toggle("bad", !ok);
  }
  function setStatus(where, text, ok) {
    (where === "setup" ? $("statusSetup") : $("statusPilot")).textContent = text;
    setDot(where, ok);
  }

  function msToLap(ms) {
    if (ms == null) return "—";
    const n = Number(ms);
    if (!Number.isFinite(n) || n <= 0) return "—";
    const totalMs = Math.round(n);
    const sec = Math.floor(totalMs / 1000);
    const msPart = String(totalMs % 1000).padStart(3, "0");
    const min = Math.floor(sec / 60);
    const secPart = String(sec % 60).padStart(2, "0");
    return `${min}:${secPart}.${msPart}`;
  }

  function setValue(id, nextText) {
    const el = $(id);
    if (el.textContent === nextText) return;
    el.textContent = nextText;
    el.classList.remove("pop");
    void el.offsetWidth;
    el.classList.add("pop");
  }

  function buildWorkerWsUrl(pageUrl) {
    const encoded = encodeURIComponent(pageUrl.trim());
    return `wss://${WORKER_HOST}/ws?raceUrl=${encoded}&dropHb=1`;
  }

  function buildRaceUrlFromId(raceId) {
    return `https://miks.racemann.com/Race/id/${raceId}#race`;
  }

  // ===== KEY FIX: parse SignalR messages separated by \x1e =====
  function parseSignalRMessages(text) {
    if (typeof text !== "string") return [];
    // SignalR JSON protocol uses record separator 0x1e
    const parts = text.split("\x1e").map(s => s.trim()).filter(Boolean);
    const out = [];
    for (const p of parts) {
      try { out.push(JSON.parse(p)); } catch {}
    }
    return out;
  }

  // ===== Extractors (both formats) =====
  // A) "old" worker-normalized format: {M:[{H,M,A}]}
  function normalizeOldFrame(obj) {
    if (!obj) return null;
    if (obj.type === "frame") return obj;
    if (Array.isArray(obj.M)) return obj;
    if (Array.isArray(obj)) return { M: obj };
    return null;
  }

  function extractLastRaceIdFromOldFrame(frame) {
    const arr = Array.isArray(frame?.M) ? frame.M : [];
    for (const m of arr) {
      if (!m) continue;
      if (m.H !== "RaceHub") continue;
      if (m.M !== "lastRaceId") continue;
      const a0 = m.A?.[0];
      const id = (typeof a0 === "string") ? a0 : (a0?.id ?? a0?.Id ?? a0?.raceId ?? a0?.RaceId);
      if (typeof id === "string" && id.trim()) return id.trim();
    }
    return null;
  }

  // B) "pure SignalR" format: {type:1,target:"lastRaceId",arguments:[{id:"..."}]}
  function extractLastRaceIdFromSignalR(obj) {
    const target = obj?.target || obj?.Target;
    if (target !== "lastRaceId") return null;
    const a0 = obj?.arguments?.[0] || obj?.Arguments?.[0];
    const id = a0?.id ?? a0?.Id ?? a0?.raceId ?? a0?.RaceId;
    if (typeof id === "string" && id.trim()) return id.trim();
    return null;
  }

  function updateRaceIdUI() {
    $("raceIdBox").value = state.raceId || "—";
    const ok = !!state.raceId && state.raceIdWsConnected;
    const statusText = ok ? "raceId live" : (state.raceIdWsConnected ? "waiting raceId…" : "connecting…");
    setStatus("setup", statusText, ok);

    $("btnOpen").disabled = !(state.raceId && $("rn").value.trim());

    const line = $("raceLinkLine");
    if (state.raceId) {
      line.innerHTML = `Текущий заезд: <span class="mono">${buildRaceUrlFromId(state.raceId)}</span>`;
    } else {
      line.textContent = "";
    }
  }

  // ===== lastRace watcher =====
  let lastReconnectTimer = null;
  let lastReconnectDelayMs = 1200;

  function scheduleLastReconnect() {
    if (lastReconnectTimer) return;
    const delay = Math.min(lastReconnectDelayMs, 12000);
    lastReconnectDelayMs = Math.min(lastReconnectDelayMs * 1.6, 12000);
    log(`last-ws: reconnect in ${delay}ms`);
    lastReconnectTimer = setTimeout(() => {
      lastReconnectTimer = null;
      connectLastRaceWatcher();
    }, delay);
  }

  function applyRaceId(id) {
    if (!id || id === state.raceId) return;
    const prev = state.raceId;
    state.raceId = id;
    state.raceIdUpdatedAt = Date.now();
    log(`last-ws: GOT raceId=${id} (prev=${prev || "—"})`);
    updateRaceIdUI();

    // if pilot screen is open -> reconnect to new race automatically
    const pilotVisible = !$("pilotScreen").classList.contains("hidden");
    if (pilotVisible && state.pilotConnected) connectPilotToRaceId(id);
  }

  function connectLastRaceWatcher() {
    if (wsLast) { try { wsLast.close(1000, "reconnect"); } catch {} wsLast = null; }

    const wsUrl = buildWorkerWsUrl(HOME_LAST_URL);
    state.raceIdWsConnected = false;
    updateRaceIdUI();
    log(`last-ws: connect -> ${wsUrl}`);

    try { wsLast = new WebSocket(wsUrl); }
    catch (e) {
      log(`last-ws: ctor failed: ${String(e)}`);
      scheduleLastReconnect();
      return;
    }

    wsLast.addEventListener("open", () => {
      state.raceIdWsConnected = true;
      lastReconnectDelayMs = 1200;
      log("last-ws: open");
      updateRaceIdUI();
    });

    wsLast.addEventListener("close", (e) => {
      state.raceIdWsConnected = false;
      log(`last-ws: close code=${e.code}`);
      updateRaceIdUI();
      scheduleLastReconnect();
    });

    wsLast.addEventListener("error", () => {
      state.raceIdWsConnected = false;
      log("last-ws: error");
      updateRaceIdUI();
    });

    wsLast.addEventListener("message", (evt) => {
      const text = typeof evt.data === "string" ? evt.data : "";
      const msgs = parseSignalRMessages(text);

      if (!msgs.length) {
        log(`last-ws: non-json/bad msg (len=${text.length})`);
        return;
      }

      // try both formats per message
      for (const obj of msgs) {
        // pure SignalR
        const idSig = extractLastRaceIdFromSignalR(obj);
        if (idSig) { applyRaceId(idSig); continue; }

        // old normalized frame
        const frame = normalizeOldFrame(obj);
        if (frame) {
          const idOld = extractLastRaceIdFromOldFrame(frame);
          if (idOld) applyRaceId(idOld);
        }
      }
    });
  }

  // watchdog
  setInterval(() => {
    const age = state.raceIdUpdatedAt ? (Date.now() - state.raceIdUpdatedAt) : Infinity;
    if (!wsLast) return connectLastRaceWatcher();
    if (age > 45000) {
      log("last-ws: watchdog reconnect (>45s w/o updates)");
      connectLastRaceWatcher();
    }
  }, 15000);

  // ===== Pilot =====
  function resetPilotState() {
    state.byRn.clear();
    state.bestRaceMs = null;
    state.frames = 0;
    state.compCount = 0;
    state.lastFrameAt = null;

    setValue("kPos", "—");
    setValue("kLast", "—");
    setValue("kBestPilot", "—");
    setValue("kBestRace", "—");

    const bestPilotEl = $("kBestPilot");
    bestPilotEl.classList.remove("purple");
    bestPilotEl.classList.add("green");
  }

  function handleCompOld(cmd) {
    if ((cmd?.Method || "").toLowerCase() !== "comp") return;
    const c = cmd.Command;
    if (!c || typeof c !== "object") return;

    const rn = String(c.rn ?? c.RN ?? "").trim();
    if (!rn) return;

    const prev = state.byRn.get(rn) || {};
    const bestLapMs = Number.isFinite(+c.bl) ? +c.bl : (prev.bestLapMs ?? null);

    state.byRn.set(rn, {
      rn,
      position: Number.isFinite(+c.pos) ? +c.pos : (prev.position ?? null),
      lastLapMs: Number.isFinite(+c.ll) ? +c.ll : (prev.lastLapMs ?? null),
      bestLapMs,
      updatedAt: Date.now(),
    });

    if (Number.isFinite(bestLapMs) && bestLapMs > 0) {
      if (state.bestRaceMs == null || bestLapMs < state.bestRaceMs) state.bestRaceMs = bestLapMs;
    }
  }

  function renderPilot() {
    const rn = String($("rn").value.trim());
    $("rnShow").textContent = rn || "—";

    const p = rn ? state.byRn.get(rn) : null;

    setValue("kPos", (p?.position ?? "—") + "");
    setValue("kLast", p ? msToLap(p.lastLapMs) : "—");
    setValue("kBestPilot", p ? msToLap(p.bestLapMs) : "—");
    setValue("kBestRace", msToLap(state.bestRaceMs));

    const bestPilotMs = (p && Number.isFinite(+p.bestLapMs)) ? +p.bestLapMs : null;
    const bestRaceMs = (state.bestRaceMs != null && Number.isFinite(+state.bestRaceMs)) ? +state.bestRaceMs : null;
    const isPilotOverallBest = (bestPilotMs != null && bestRaceMs != null && bestPilotMs === bestRaceMs);

    const bestPilotEl = $("kBestPilot");
    bestPilotEl.classList.toggle("purple", isPilotOverallBest);
    bestPilotEl.classList.toggle("green", !isPilotOverallBest);

    const last = state.lastFrameAt ? new Date(state.lastFrameAt).toLocaleTimeString() : "—";
    const raceIdShort = state.raceId ? state.raceId.slice(0, 8) : "—";
    $("metaLine").textContent = `raceId: ${raceIdShort} • Frames: ${state.frames} • comp: ${state.compCount} • last: ${last}`;
  }

  function showSetup() {
    $("pilotScreen").classList.add("hidden");
    $("setupScreen").classList.remove("hidden");
  }

  function showPilotConnecting() {
    $("setupScreen").classList.add("hidden");
    $("pilotScreen").classList.remove("hidden");
    setStatus("pilot", "connecting…", false);
  }

  async function disconnectPilot(goToSetup = true) {
    state.pilotConnected = false;
    if (wsPilot) {
      try { wsPilot.close(1000, "bye"); } catch {}
      wsPilot = null;
    }
    $("btnDisconnect").disabled = true;
    setStatus("pilot", "disconnected", false);
    if (goToSetup) showSetup();
  }

  function connectPilotToRaceId(raceId) {
    if (!raceId) { alert("raceId ещё не получен"); return; }
    const rn = $("rn").value.trim();
    if (!rn) { alert("Введи RN"); return; }
    try { localStorage.setItem(LS_RN, rn); } catch {}

    const raceUrl = buildRaceUrlFromId(raceId);
    const wsUrl = buildWorkerWsUrl(raceUrl);

    showPilotConnecting();
    resetPilotState();
    disconnectPilot(false);

    try { wsPilot = new WebSocket(wsUrl); }
    catch (e) { alert("Не удалось создать WebSocket: " + e); showSetup(); return; }

    $("btnDisconnect").disabled = false;

    wsPilot.addEventListener("open", () => {
      state.pilotConnected = true;
      setStatus("pilot", "connected", true);
      renderPilot();
    });

    wsPilot.addEventListener("close", (e) => {
      state.pilotConnected = false;
      setStatus("pilot", `closed (${e.code})`, false);
      $("btnDisconnect").disabled = true;
      wsPilot = null;
    });

    wsPilot.addEventListener("error", () => {
      setStatus("pilot", "error", false);
    });

    wsPilot.addEventListener("message", (evt) => {
      const text = typeof evt.data === "string" ? evt.data : "";
      const msgs = parseSignalRMessages(text);
      if (!msgs.length) return;

      for (const obj of msgs) {
        const frame = normalizeOldFrame(obj);
        if (!frame) continue;

        state.frames += 1;
        state.lastFrameAt = Date.now();

        const arr = Array.isArray(frame?.M) ? frame.M : [];
        for (const m of arr) {
          if (m?.H === "RaceHub" && m?.M === "newCommand") {
            const cmd = m?.A?.[0];
            if (cmd && (cmd?.Method || "").toLowerCase() === "comp") {
              state.compCount += 1;
              handleCompOld(cmd);
            }
          }
        }
      }
      renderPilot();
    });

    renderPilot();
  }

  // ===== Events & init =====
  $("btnOpen").addEventListener("click", () => connectPilotToRaceId(state.raceId));
  $("btnDisconnect").addEventListener("click", () => disconnectPilot(true));
  $("btnBack").addEventListener("click", () => disconnectPilot(true));

  $("btnClearLog").addEventListener("click", () => {
    logLines.length = 0;
    $("log").value = "";
  });

  $("rn").addEventListener("input", updateRaceIdUI);

  try {
    const savedRn = localStorage.getItem(LS_RN);
    if (savedRn) $("rn").value = savedRn;
  } catch {}

  showSetup();
  connectLastRaceWatcher();
  updateRaceIdUI();
})();
</script>
</body>
</html>
