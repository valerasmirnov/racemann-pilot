<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RaceMann — разбор SignalR newCommand (экран-отладчик)</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial; margin: 16px; background:#0b0c10; color:#e8e8ea; }
    h2 { margin: 0 0 10px; }
    .muted { color:#9aa0a6; font-size: 13px; line-height: 1.35; }
    input, button, select, textarea { font-size: 15px; padding: 10px; border-radius: 12px; border: 1px solid #2a2f3a; background:#0f1116; color:#e8e8ea; }
    input, textarea { width: 100%; box-sizing: border-box; }
    button { cursor: pointer; font-weight: 700; background:#1f6feb; border-color:#1f6feb; }
    button.secondary { background:#0f1116; border-color:#2a2f3a; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; margin-top: 10px; }
    .card { border:1px solid #2a2f3a; border-radius: 14px; padding: 12px; margin-top: 12px; background:#14161c; }
    .kpi { display:flex; gap:10px; flex-wrap: wrap; }
    .kpi > div { border:1px solid #2a2f3a; border-radius: 14px; padding: 10px 12px; background:#0f1116; min-width: 210px; }
    label { font-weight: 700; display:block; margin-bottom: 6px; }
    pre, textarea { white-space: pre-wrap; word-break: break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    pre { background:#0f1116; border:1px solid #2a2f3a; border-radius: 12px; padding: 10px; max-height: 44vh; overflow: auto; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #242833; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { color:#9aa0a6; font-weight: 700; }
    .pill { display:inline-block; padding:4px 8px; border:1px solid #2a2f3a; border-radius: 999px; font-size: 12px; color:#9aa0a6; }
  </style>
</head>
<body>
  <h2>RaceMann — разбор SignalR <span class="pill">newCommand</span> (через ваш Worker)</h2>
  <div class="muted">
    Это отладочный экран, который подключается к вашему Cloudflare Worker (<b>/ws</b>) и:
    <ul>
      <li>показывает поток кадров,</li>
      <li>выделяет сообщения <b>RaceHub/newCommand</b>,</li>
      <li>строит частотник по типу команды (<b>Method/Type/Command/Name</b>),</li>
      <li>даёт быстрый поиск по сырому JSON.</li>
    </ul>
    Важно: Worker должен уже слать кадры в формате, как в твоём коде: <b>{type:"frame", C, M, raw}</b>.
  </div>

  <div class="card">
    <label>Worker WebSocket URL</label>
    <input id="workerWs" placeholder="wss://YOUR-WORKER.workers.dev/ws?raceUrl=https%3A%2F%2Fmiks.racemann.com%2FRace%2Fid%2F...%23race&dropHb=1" />

    <div class="row">
      <label style="margin:0">Показывать raw кадров:</label>
      <select id="rawMode" style="min-width:220px">
        <option value="none">не показывать</option>
        <option value="only_has">только когда есть newCommand</option>
        <option value="all">все кадры</option>
      </select>

      <label style="margin:0">Макс raw в памяти:</label>
      <input id="maxKeep" style="width:120px" value="200" />

      <button id="btnConnect">Connect</button>
      <button id="btnDisconnect" class="secondary" disabled>Disconnect</button>
      <button id="btnDownload" class="secondary" disabled>Download JSON</button>
      <button id="btnClear" class="secondary">Clear</button>
    </div>

    <div class="row">
      <label style="margin:0">Фильтр по kind (regex):</label>
      <input id="kindFilter" style="min-width:320px" placeholder="например: lap|position|penalty" />
      <label style="margin:0">Поиск в raw:</label>
      <input id="rawSearch" style="min-width:320px" placeholder="например: \"Penalty\" или Kart" />
    </div>
  </div>

  <div class="card">
    <div class="kpi">
      <div><b>Status</b><div id="status" class="muted" style="margin-top:6px">idle</div></div>
      <div><b>Frames</b><div id="frames" class="muted" style="margin-top:6px">0</div></div>
      <div><b>newCommand</b><div id="newcmd" class="muted" style="margin-top:6px">0</div></div>
      <div><b>Last C</b><div id="lastC" class="muted" style="margin-top:6px">—</div></div>
    </div>
  </div>

  <div class="card">
    <label>Частота команд (kind)</label>
    <div class="muted">kind вычисляется из <b>cmd.Method / cmd.Type / cmd.Command / cmd.Name</b> (и lower-case).</div>
    <div style="margin-top:10px; overflow:auto; max-height: 28vh;">
      <table id="freqTable">
        <thead>
          <tr><th style="width:60px">#</th><th>kind</th><th style="width:90px">count</th><th>пример ключей cmd</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <label>Лента “интересных” событий (RaceHub/newCommand)</label>
    <div class="muted">Здесь показываются только команды, которые прошли фильтр kind (если задан).</div>
    <pre id="events"></pre>
  </div>

  <div class="card">
    <label>Raw log (по выбранному режиму)</label>
    <pre id="raw"></pre>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ----- State -----
  let ws = null;
  let frames = 0;
  let newCmdTotal = 0;
  let lastC = null;

  // keep last N raw frames for download
  let keepMax = 200;
  const kept = []; // {ts, frame} minimal
  const freq = new Map(); // kind -> {count, sampleKeys[]}
  const lastEvents = []; // strings
  const lastRawLines = []; // strings

  const MAX_EVENTS_LINES = 800;
  const MAX_RAW_LINES = 800;

  function setStatus(s) { $("status").textContent = s; }
  function updateKpi() {
    $("frames").textContent = String(frames);
    $("newcmd").textContent = String(newCmdTotal);
    $("lastC").textContent = lastC ?? "—";
    $("btnDownload").disabled = kept.length === 0;
  }

  function safeJsonParse(s) {
    if (typeof s !== "string") return null;
    const t = s.trim();
    if (!t) return null;
    if (!(t.startsWith("{") || t.startsWith("["))) return null;
    try { return JSON.parse(t); } catch { return null; }
  }

  function detectKind(cmd) {
    const v =
      cmd?.Method ?? cmd?.method ??
      cmd?.Type ?? cmd?.type ??
      cmd?.Command ?? cmd?.command ??
      cmd?.Name ?? cmd?.name ??
      "unknown";
    return String(v).toLowerCase();
  }

  function extractCommandsFromWorkerFrame(workerMsg) {
    // Expected worker frame:
    // { type:"frame", C, M, raw, ... }
    // where M is array of SignalR messages: [{H,M,A}, ...]
    const out = [];
    const M = Array.isArray(workerMsg?.M) ? workerMsg.M : [];
    for (const msg of M) {
      if (!msg) continue;
      if (msg.H !== "RaceHub") continue;

      if (msg.M === "newCommand") {
        const cmd = msg.A?.[0] ?? null;
        const kind = detectKind(cmd);
        out.push({ kind, cmd, hub: msg.H, method: msg.M });
      } else {
        out.push({ kind: String(msg.M).toLowerCase(), cmd: msg.A?.[0] ?? null, hub: msg.H, method: msg.M });
      }
    }
    return out;
  }

  function pushLimited(arr, item, max) {
    arr.push(item);
    if (arr.length > max) arr.splice(0, arr.length - max);
  }

  function renderFreqTable() {
    const tbody = $("freqTable").querySelector("tbody");
    tbody.innerHTML = "";

    const rows = Array.from(freq.entries())
      .map(([kind, v]) => ({ kind, count: v.count, keys: v.sampleKeys || [] }))
      .sort((a,b) => b.count - a.count);

    let i = 1;
    for (const r of rows) {
      const tr = document.createElement("tr");

      const tdI = document.createElement("td");
      tdI.textContent = String(i++);

      const tdK = document.createElement("td");
      tdK.textContent = r.kind;

      const tdC = document.createElement("td");
      tdC.textContent = String(r.count);

      const tdKeys = document.createElement("td");
      tdKeys.textContent = r.keys.slice(0, 20).join(", ");

      tr.appendChild(tdI);
      tr.appendChild(tdK);
      tr.appendChild(tdC);
      tr.appendChild(tdKeys);
      tbody.appendChild(tr);
    }
  }

  function renderEvents() {
    $("events").textContent = lastEvents.join("\n");
  }

  function renderRaw() {
    $("raw").textContent = lastRawLines.join("\n");
  }

  function clearAll() {
    frames = 0;
    newCmdTotal = 0;
    lastC = null;
    kept.length = 0;
    freq.clear();
    lastEvents.length = 0;
    lastRawLines.length = 0;
    renderFreqTable();
    renderEvents();
    renderRaw();
    updateKpi();
    setStatus("cleared");
  }

  function downloadJson() {
    const blob = new Blob([JSON.stringify({
      collectedAt: new Date().toISOString(),
      workerWs: $("workerWs").value.trim(),
      stats: { frames, newCmdTotal, lastC },
      freq: Array.from(freq.entries()).map(([k,v]) => ({ kind:k, count:v.count, sampleKeys:v.sampleKeys })),
      kept
    }, null, 2)], { type:"application/json" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `racemann_debug_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function isKindAllowed(kind) {
    const re = $("kindFilter").value.trim();
    if (!re) return true;
    try {
      return new RegExp(re, "i").test(kind);
    } catch {
      return true; // invalid regex: don't block
    }
  }

  function rawMatchesSearch(raw) {
    const q = $("rawSearch").value.trim();
    if (!q) return true;
    return String(raw).toLowerCase().includes(q.toLowerCase());
  }

  function addFreq(kind, cmd) {
    const entry = freq.get(kind) || { count: 0, sampleKeys: [] };
    entry.count += 1;
    if (cmd && typeof cmd === "object") {
      const keys = Object.keys(cmd);
      // keep a stable-ish sample of keys
      if (entry.sampleKeys.length === 0 && keys.length) entry.sampleKeys = keys.slice(0, 30);
    }
    freq.set(kind, entry);
  }

  function connect() {
    const url = $("workerWs").value.trim();
    keepMax = Math.max(50, parseInt($("maxKeep").value, 10) || 200);

    if (!url) {
      alert("Вставь Worker WebSocket URL");
      return;
    }

    disconnect();

    try {
      ws = new WebSocket(url);
    } catch (e) {
      alert("Не удалось создать WebSocket: " + e);
      return;
    }

    setStatus("connecting...");
    $("btnConnect").disabled = true;
    $("btnDisconnect").disabled = false;

    ws.addEventListener("open", () => {
      setStatus("connected");
    });

    ws.addEventListener("close", (e) => {
      setStatus(`closed (${e.code}) ${e.reason || ""}`.trim());
      $("btnConnect").disabled = false;
      $("btnDisconnect").disabled = true;
      ws = null;
    });

    ws.addEventListener("error", () => {
      setStatus("error");
    });

    ws.addEventListener("message", (evt) => {
      const text = typeof evt.data === "string" ? evt.data : "";
      const msg = safeJsonParse(text);

      if (!msg) return;

      // Worker sends statuses too
      if (msg.type && msg.type !== "frame") {
        pushLimited(lastRawLines, `[${new Date().toLocaleTimeString()}] STATUS ${msg.stage || msg.type}: ${JSON.stringify(msg)}`, MAX_RAW_LINES);
        renderRaw();
        return;
      }

      if (msg.type === "frame") {
        frames += 1;
        lastC = msg.C ?? lastC;

        // keep minimal
        pushLimited(kept, { ts: msg.ts || Date.now(), C: msg.C ?? null, M: msg.M ?? null, raw: msg.raw ?? null }, keepMax);

        // Extract commands (RaceHub/newCommand)
        const cmds = extractCommandsFromWorkerFrame(msg);

        // Update frequency + events
        for (const it of cmds) {
          addFreq(it.kind, it.cmd);

          if (!isKindAllowed(it.kind)) continue;

          // Make a compact line to read
          const keys = it.cmd && typeof it.cmd === "object" ? Object.keys(it.cmd).slice(0, 12).join(",") : "";
          const line =
            `[${new Date().toLocaleTimeString()}] kind=${it.kind} keys=[${keys}] ` +
            (it.cmd ? `cmd=${JSON.stringify(it.cmd).slice(0, 500)}` : "");

          pushLimited(lastEvents, line, MAX_EVENTS_LINES);

          // count only real newCommand
          if (it.method === "newCommand") newCmdTotal += 1;
        }

        // Raw log mode
        const rawMode = $("rawMode").value;
        const hasInteresting = cmds.some(x => x.method === "newCommand");
        const shouldShowRaw =
          rawMode === "all" ||
          (rawMode === "only_has" && hasInteresting);

        if (shouldShowRaw && rawMatchesSearch(msg.raw ?? "")) {
          pushLimited(
            lastRawLines,
            `[${new Date().toLocaleTimeString()}] frame#${frames} C=${msg.C ?? "—"} raw=${String(msg.raw ?? "").slice(0, 1200)}`,
            MAX_RAW_LINES
          );
        }

        // Render (cheap, but ok for debug)
        updateKpi();
        renderFreqTable();
        renderEvents();
        renderRaw();
      }
    });
  }

  function disconnect() {
    if (ws) {
      try { ws.close(1000, "bye"); } catch {}
      ws = null;
    }
    $("btnConnect").disabled = false;
    $("btnDisconnect").disabled = true;
    setStatus("disconnected");
  }

  $("btnConnect").addEventListener("click", connect);
  $("btnDisconnect").addEventListener("click", disconnect);
  $("btnDownload").addEventListener("click", downloadJson);
  $("btnClear").addEventListener("click", clearAll);

  // Small helpers for quick paste:
  // Build Worker URL from base + Race URL (optional)
  // You can ignore, but it's handy.
  const suggest = () => {
    const v = $("workerWs").value.trim();
    if (v) return;
    // Placeholder hint only; user fills manually
    $("workerWs").value = "wss://YOUR-WORKER.workers.dev/ws?raceUrl=" +
      encodeURIComponent("https://miks.racemann.com/Race/id/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx#race") +
      "&dropHb=1";
  };
  suggest();
  updateKpi();
})();
</script>
</body>
</html>
